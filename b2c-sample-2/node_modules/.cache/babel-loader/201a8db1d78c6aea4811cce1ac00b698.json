{"ast":null,"code":"/*! @azure/msal-browser v2.16.0 2021-07-22 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\r\n */\n// RSA KeyGen Algorithm\nvar PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\";\n// SHA-256 hashing algorithm\nvar S256_HASH_ALG = \"SHA-256\";\n// MOD length for PoP tokens\nvar MODULUS_LENGTH = 2048;\n// Public Exponent\nvar PUBLIC_EXPONENT = new Uint8Array([0x01, 0x00, 0x01]);\n/**\r\n * This class implements functions used by the browser library to perform cryptography operations such as\r\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\r\n */\nvar BrowserCrypto = /** @class */function () {\n  function BrowserCrypto() {\n    if (!this.hasCryptoAPI()) {\n      throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto or msCrypto object not available.\");\n    }\n    this._keygenAlgorithmOptions = {\n      name: PKCS1_V15_KEYGEN_ALG,\n      hash: S256_HASH_ALG,\n      modulusLength: MODULUS_LENGTH,\n      publicExponent: PUBLIC_EXPONENT\n    };\n  }\n  /**\r\n   * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\r\n   * @param dataString\r\n   */\n  BrowserCrypto.prototype.sha256Digest = function (dataString) {\n    return __awaiter(this, void 0, void 0, function () {\n      var data;\n      return __generator(this, function (_a) {\n        data = BrowserStringUtils.stringToUtf8Arr(dataString);\n        return [2 /*return*/, this.hasIECrypto() ? this.getMSCryptoDigest(S256_HASH_ALG, data) : this.getSubtleCryptoDigest(S256_HASH_ALG, data)];\n      });\n    });\n  };\n  /**\r\n   * Populates buffer with cryptographically random values.\r\n   * @param dataBuffer\r\n   */\n  BrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    var cryptoObj = window[\"msCrypto\"] || window.crypto;\n    if (!cryptoObj.getRandomValues) {\n      throw BrowserAuthError.createCryptoNotAvailableError(\"getRandomValues does not exist.\");\n    }\n    cryptoObj.getRandomValues(dataBuffer);\n  };\n  /**\r\n   * Generates a keypair based on current keygen algorithm config.\r\n   * @param extractable\r\n   * @param usages\r\n   */\n  BrowserCrypto.prototype.generateKeyPair = function (extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.hasIECrypto() ? this.msCryptoGenerateKey(extractable, usages) : window.crypto.subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Export key as Json Web Key (JWK)\r\n   * @param key\r\n   * @param format\r\n   */\n  BrowserCrypto.prototype.exportJwk = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.hasIECrypto() ? this.msCryptoExportJwk(key) : window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key)];\n      });\n    });\n  };\n  /**\r\n   * Imports key as Json Web Key (JWK), can set extractable and usages.\r\n   * @param key\r\n   * @param format\r\n   * @param extractable\r\n   * @param usages\r\n   */\n  BrowserCrypto.prototype.importJwk = function (key, extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var keyString, keyBuffer;\n      return __generator(this, function (_a) {\n        keyString = BrowserCrypto.getJwkString(key);\n        keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n        return [2 /*return*/, this.hasIECrypto() ? this.msCryptoImportKey(keyBuffer, extractable, usages) : window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, this._keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Signs given data with given key\r\n   * @param key\r\n   * @param data\r\n   */\n  BrowserCrypto.prototype.sign = function (key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.hasIECrypto() ? this.msCryptoSign(key, data) : window.crypto.subtle.sign(this._keygenAlgorithmOptions, key, data)];\n      });\n    });\n  };\n  /**\r\n   * Check whether IE crypto or other browser cryptography is available.\r\n   */\n  BrowserCrypto.prototype.hasCryptoAPI = function () {\n    return this.hasIECrypto() || this.hasBrowserCrypto();\n  };\n  /**\r\n   * Checks whether IE crypto (AKA msCrypto) is available.\r\n   */\n  BrowserCrypto.prototype.hasIECrypto = function () {\n    return \"msCrypto\" in window;\n  };\n  /**\r\n   * Check whether browser crypto is available.\r\n   */\n  BrowserCrypto.prototype.hasBrowserCrypto = function () {\n    return \"crypto\" in window;\n  };\n  /**\r\n   * Helper function for SHA digest.\r\n   * @param algorithm\r\n   * @param data\r\n   */\n  BrowserCrypto.prototype.getSubtleCryptoDigest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, window.crypto.subtle.digest(algorithm, data)];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for SHA digest.\r\n   * @param algorithm\r\n   * @param data\r\n   */\n  BrowserCrypto.prototype.getMSCryptoDigest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n          digestOperation.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          digestOperation.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for generating a keypair\r\n   * @param extractable\r\n   * @param usages\r\n   */\n  BrowserCrypto.prototype.msCryptoGenerateKey = function (extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msGenerateKey = window[\"msCrypto\"].subtle.generateKey(_this._keygenAlgorithmOptions, extractable, usages);\n          msGenerateKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msGenerateKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for exportKey\r\n   * @param key\r\n   * @param format\r\n   */\n  BrowserCrypto.prototype.msCryptoExportJwk = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n          msExportKey.addEventListener(\"complete\", function (e) {\n            var resultBuffer = e.target.result;\n            var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer)).replace(/\\r/g, \"\").replace(/\\n/g, \"\").replace(/\\t/g, \"\").split(\" \").join(\"\").replace(\"\\u0000\", \"\");\n            try {\n              resolve(JSON.parse(resultString));\n            } catch (e) {\n              reject(e);\n            }\n          });\n          msExportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for importKey\r\n   * @param key\r\n   * @param format\r\n   * @param extractable\r\n   * @param usages\r\n   */\n  BrowserCrypto.prototype.msCryptoImportKey = function (keyBuffer, extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, _this._keygenAlgorithmOptions, extractable, usages);\n          msImportKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msImportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for sign JWT\r\n   * @param key\r\n   * @param data\r\n   */\n  BrowserCrypto.prototype.msCryptoSign = function (key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msSign = window[\"msCrypto\"].subtle.sign(_this._keygenAlgorithmOptions, key, data);\n          msSign.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msSign.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * Returns stringified jwk.\r\n   * @param jwk\r\n   */\n  BrowserCrypto.getJwkString = function (jwk) {\n    return JSON.stringify(jwk, Object.keys(jwk).sort());\n  };\n  return BrowserCrypto;\n}();\nexport { BrowserCrypto };","map":{"version":3,"mappings":"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","names":["PKCS1_V15_KEYGEN_ALG","S256_HASH_ALG","MODULUS_LENGTH","PUBLIC_EXPONENT","Uint8Array","hasCryptoAPI","BrowserAuthError","createCryptoNotAvailableError","_keygenAlgorithmOptions","name","hash","modulusLength","publicExponent","BrowserCrypto","dataString","data","BrowserStringUtils","stringToUtf8Arr","hasIECrypto","getMSCryptoDigest","getSubtleCryptoDigest","dataBuffer","cryptoObj","window","crypto","getRandomValues","extractable","usages","msCryptoGenerateKey","subtle","generateKey","key","msCryptoExportJwk","exportKey","KEY_FORMAT_JWK","keyString","getJwkString","keyBuffer","stringToArrayBuffer","msCryptoImportKey","importKey","msCryptoSign","sign","hasBrowserCrypto","algorithm","digest","Promise","resolve","reject","digestOperation","buffer","addEventListener","e","target","result","error","msGenerateKey","_this","msExportKey","resultBuffer","resultString","utf8ArrToString","replace","split","join","JSON","parse","msImportKey","msSign","jwk","stringify","Object","keys","sort"],"sources":["../../src/crypto/BrowserCrypto.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\r\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\r\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\r\n/**\r\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\r\n */\r\n// RSA KeyGen Algorithm\r\nconst PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\";\r\n// SHA-256 hashing algorithm\r\nconst S256_HASH_ALG = \"SHA-256\";\r\n// MOD length for PoP tokens\r\nconst MODULUS_LENGTH = 2048;\r\n// Public Exponent\r\nconst PUBLIC_EXPONENT: Uint8Array = new Uint8Array([0x01, 0x00, 0x01]);\r\n\r\n/**\r\n * This class implements functions used by the browser library to perform cryptography operations such as\r\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\r\n */\r\nexport class BrowserCrypto {\r\n\r\n    private _keygenAlgorithmOptions: RsaHashedKeyGenParams;\r\n\r\n    constructor() {\r\n        if (!(this.hasCryptoAPI())) {\r\n            throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto or msCrypto object not available.\");\r\n        }\r\n\r\n        this._keygenAlgorithmOptions = {\r\n            name: PKCS1_V15_KEYGEN_ALG,\r\n            hash: S256_HASH_ALG,\r\n            modulusLength: MODULUS_LENGTH,\r\n            publicExponent: PUBLIC_EXPONENT\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\r\n     * @param dataString \r\n     */\r\n    async sha256Digest(dataString: string): Promise<ArrayBuffer> {\r\n        const data = BrowserStringUtils.stringToUtf8Arr(dataString);\r\n\r\n        return this.hasIECrypto() ? this.getMSCryptoDigest(S256_HASH_ALG, data) : this.getSubtleCryptoDigest(S256_HASH_ALG, data);\r\n    }\r\n\r\n    /**\r\n     * Populates buffer with cryptographically random values.\r\n     * @param dataBuffer \r\n     */\r\n    getRandomValues(dataBuffer: Uint8Array): void {\r\n        const cryptoObj = window[\"msCrypto\"] || window.crypto;\r\n        if (!cryptoObj.getRandomValues) {\r\n            throw BrowserAuthError.createCryptoNotAvailableError(\"getRandomValues does not exist.\");\r\n        }\r\n        cryptoObj.getRandomValues(dataBuffer);\r\n    }\r\n\r\n    /**\r\n     * Generates a keypair based on current keygen algorithm config.\r\n     * @param extractable \r\n     * @param usages \r\n     */\r\n    async generateKeyPair(extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKeyPair> {\r\n        return (\r\n            this.hasIECrypto() ? \r\n                this.msCryptoGenerateKey(extractable, usages) \r\n                : window.crypto.subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages)\r\n        ) as Promise<CryptoKeyPair>;\r\n    }\r\n\r\n    /**\r\n     * Export key as Json Web Key (JWK)\r\n     * @param key \r\n     * @param format \r\n     */\r\n    async exportJwk(key: CryptoKey): Promise<JsonWebKey> {\r\n        return this.hasIECrypto() ? this.msCryptoExportJwk(key) : window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key);\r\n    }\r\n\r\n    /**\r\n     * Imports key as Json Web Key (JWK), can set extractable and usages.\r\n     * @param key \r\n     * @param format \r\n     * @param extractable \r\n     * @param usages \r\n     */\r\n    async importJwk(key: JsonWebKey, extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKey> {\r\n        const keyString = BrowserCrypto.getJwkString(key);\r\n        const keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\r\n\r\n        return this.hasIECrypto() ? \r\n            this.msCryptoImportKey(keyBuffer, extractable, usages) \r\n            : window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, this._keygenAlgorithmOptions, extractable, usages);\r\n    }\r\n\r\n    /**\r\n     * Signs given data with given key\r\n     * @param key \r\n     * @param data \r\n     */\r\n    async sign(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\r\n        return this.hasIECrypto() ?\r\n            this.msCryptoSign(key, data)\r\n            : window.crypto.subtle.sign(this._keygenAlgorithmOptions, key, data);\r\n    }\r\n\r\n    /**\r\n     * Check whether IE crypto or other browser cryptography is available.\r\n     */\r\n    private hasCryptoAPI(): boolean {\r\n        return this.hasIECrypto() || this.hasBrowserCrypto();\r\n    }\r\n\r\n    /**\r\n     * Checks whether IE crypto (AKA msCrypto) is available.\r\n     */\r\n    private hasIECrypto(): boolean {\r\n        return \"msCrypto\" in window;\r\n    }\r\n\r\n    /**\r\n     * Check whether browser crypto is available.\r\n     */\r\n    private hasBrowserCrypto(): boolean {\r\n        return \"crypto\" in window;\r\n    }\r\n\r\n    /**\r\n     * Helper function for SHA digest.\r\n     * @param algorithm \r\n     * @param data \r\n     */\r\n    private async getSubtleCryptoDigest(algorithm: string, data: Uint8Array): Promise<ArrayBuffer> {\r\n        return window.crypto.subtle.digest(algorithm, data);\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for SHA digest.\r\n     * @param algorithm \r\n     * @param data \r\n     */\r\n    private async getMSCryptoDigest(algorithm: string, data: Uint8Array): Promise<ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            const digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\r\n            digestOperation.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n            digestOperation.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for generating a keypair\r\n     * @param extractable \r\n     * @param usages \r\n     */\r\n    private async msCryptoGenerateKey(extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKeyPair> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msGenerateKey = window[\"msCrypto\"].subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages);\r\n            msGenerateKey.addEventListener(\"complete\", (e: { target: { result: CryptoKeyPair | PromiseLike<CryptoKeyPair>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msGenerateKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for exportKey\r\n     * @param key \r\n     * @param format \r\n     */\r\n    private async msCryptoExportJwk(key: CryptoKey): Promise<JsonWebKey> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\r\n            msExportKey.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer; }; }) => {\r\n                const resultBuffer: ArrayBuffer = e.target.result;\r\n\r\n                const resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer))\r\n                    .replace(/\\r/g, \"\")\r\n                    .replace(/\\n/g, \"\")\r\n                    .replace(/\\t/g, \"\")\r\n                    .split(\" \").join(\"\")\r\n                    .replace(\"\\u0000\", \"\");\r\n\r\n                try {\r\n                    resolve(JSON.parse(resultString));\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n\r\n            msExportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for importKey\r\n     * @param key \r\n     * @param format \r\n     * @param extractable \r\n     * @param usages \r\n     */\r\n    private async msCryptoImportKey(keyBuffer: ArrayBuffer, extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKey> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, this._keygenAlgorithmOptions, extractable, usages);\r\n            msImportKey.addEventListener(\"complete\", (e: { target: { result: CryptoKey | PromiseLike<CryptoKey>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msImportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for sign JWT\r\n     * @param key \r\n     * @param data \r\n     */\r\n    private async msCryptoSign(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msSign = window[\"msCrypto\"].subtle.sign(this._keygenAlgorithmOptions, key, data);\r\n            msSign.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msSign.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns stringified jwk.\r\n     * @param jwk \r\n     */\r\n    static getJwkString(jwk: JsonWebKey): string {\r\n        return JSON.stringify(jwk, Object.keys(jwk).sort());\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}