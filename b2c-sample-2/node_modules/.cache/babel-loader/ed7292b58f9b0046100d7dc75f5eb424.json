{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { Constants as Constants$1, AuthorityMetadataSource, RegionDiscoveryOutcomes } from '../utils/Constants.js';\nimport { ClientAuthError as ClientAuthError$1 } from '../error/ClientAuthError.js';\nimport { ClientConfigurationError as ClientConfigurationError$1 } from '../error/ClientConfigurationError.js';\nimport { AuthorityType as AuthorityType$1 } from './AuthorityType.js';\nimport { UrlString as UrlString$1 } from '../url/UrlString.js';\nimport { isOpenIdConfigResponse } from './OpenIdConfigResponse.js';\nimport { ProtocolMode as ProtocolMode$1 } from './ProtocolMode.js';\nimport { AuthorityMetadataEntity as AuthorityMetadataEntity$1 } from '../cache/entities/AuthorityMetadataEntity.js';\nimport { isCloudInstanceDiscoveryResponse } from './CloudInstanceDiscoveryResponse.js';\nimport { RegionDiscovery as RegionDiscovery$1 } from './RegionDiscovery.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\r\n * endpoint. It will store the pertinent config data in this object for use during token calls.\r\n */\nvar Authority = /** @class */function () {\n  function Authority(authority, networkInterface, cacheManager, authorityOptions) {\n    this.canonicalAuthority = authority;\n    this._canonicalAuthority.validateAsUri();\n    this.networkInterface = networkInterface;\n    this.cacheManager = cacheManager;\n    this.authorityOptions = authorityOptions;\n    this.regionDiscovery = new RegionDiscovery$1(networkInterface);\n    this.regionDiscoveryMetadata = {\n      region_used: undefined,\n      region_source: undefined,\n      region_outcome: undefined\n    };\n  }\n  Object.defineProperty(Authority.prototype, \"authorityType\", {\n    // See above for AuthorityType\n    get: function () {\n      var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\n      if (pathSegments.length && pathSegments[0].toLowerCase() === Constants$1.ADFS) {\n        return AuthorityType$1.Adfs;\n      }\n      return AuthorityType$1.Default;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"protocolMode\", {\n    /**\r\n     * ProtocolMode enum representing the way endpoints are constructed.\r\n     */\n    get: function () {\n      return this.authorityOptions.protocolMode;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"options\", {\n    /**\r\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\r\n     */\n    get: function () {\n      return this.authorityOptions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthority\", {\n    /**\r\n     * A URL that is the authority set by the developer\r\n     */\n    get: function () {\n      return this._canonicalAuthority.urlString;\n    },\n    /**\r\n     * Sets canonical authority.\r\n     */\n    set: function (url) {\n      this._canonicalAuthority = new UrlString$1(url);\n      this._canonicalAuthority.validateAsUri();\n      this._canonicalAuthorityUrlComponents = null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthorityUrlComponents\", {\n    /**\r\n     * Get authority components.\r\n     */\n    get: function () {\n      if (!this._canonicalAuthorityUrlComponents) {\n        this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\n      }\n      return this._canonicalAuthorityUrlComponents;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"hostnameAndPort\", {\n    /**\r\n     * Get hostname and port i.e. login.microsoftonline.com\r\n     */\n    get: function () {\n      return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tenant\", {\n    /**\r\n     * Get tenant for authority.\r\n     */\n    get: function () {\n      return this.canonicalAuthorityUrlComponents.PathSegments[0];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"authorizationEndpoint\", {\n    /**\r\n     * OAuth /authorize endpoint for requests\r\n     */\n    get: function () {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.authorization_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError$1.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tokenEndpoint\", {\n    /**\r\n     * OAuth /token endpoint for requests\r\n     */\n    get: function () {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError$1.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"deviceCodeEndpoint\", {\n    get: function () {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError$1.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"endSessionEndpoint\", {\n    /**\r\n     * OAuth logout endpoint for requests\r\n     */\n    get: function () {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.end_session_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError$1.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"selfSignedJwtAudience\", {\n    /**\r\n     * OAuth issuer for requests\r\n     */\n    get: function () {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.issuer);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError$1.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Replaces tenant in url path with current tenant. Defaults to common.\r\n   * @param urlString\r\n   */\n  Authority.prototype.replaceTenant = function (urlString) {\n    return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n  };\n  /**\r\n   * Replaces path such as tenant or policy with the current tenant or policy.\r\n   * @param urlString\r\n   */\n  Authority.prototype.replacePath = function (urlString) {\n    var endpoint = urlString;\n    var cachedAuthorityUrl = new UrlString$1(this.metadata.canonical_authority);\n    var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\n    currentAuthorityParts.forEach(function (currentPart, index) {\n      var cachedPart = cachedAuthorityParts[index];\n      if (currentPart !== cachedPart) {\n        endpoint = endpoint.replace(\"/\" + cachedPart + \"/\", \"/\" + currentPart + \"/\");\n      }\n    });\n    return endpoint;\n  };\n  Object.defineProperty(Authority.prototype, \"defaultOpenIdConfigurationEndpoint\", {\n    /**\r\n     * The default open id configuration endpoint for any canonical authority.\r\n     */\n    get: function () {\n      if (this.authorityType === AuthorityType$1.Adfs || this.protocolMode === ProtocolMode$1.OIDC) {\n        return this.canonicalAuthority + \".well-known/openid-configuration\";\n      }\n      return this.canonicalAuthority + \"v2.0/.well-known/openid-configuration\";\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Boolean that returns whethr or not tenant discovery has been completed.\r\n   */\n  Authority.prototype.discoveryComplete = function () {\n    return !!this.metadata;\n  };\n  /**\r\n   * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\r\n   * and the /authorize, /token and logout endpoints.\r\n   */\n  Authority.prototype.resolveEndpointsAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\n            if (!metadataEntity) {\n              metadataEntity = new AuthorityMetadataEntity$1();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n            return [4 /*yield*/, this.updateCloudDiscoveryMetadata(metadataEntity)];\n          case 1:\n            cloudDiscoverySource = _a.sent();\n            this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\n            return [4 /*yield*/, this.updateEndpointMetadata(metadataEntity)];\n          case 2:\n            endpointSource = _a.sent();\n            if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {\n              // Reset the expiration time unless both values came from a successful cache lookup\n              metadataEntity.resetExpiresAt();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n            cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\n            this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n            this.metadata = metadataEntity;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Update AuthorityMetadataEntity with new endpoints and return where the information came from\r\n   * @param metadataEntity\r\n   */\n  Authority.prototype.updateEndpointMetadata = function (metadataEntity) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, autodetectedRegionName, azureRegion;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            metadata = this.getEndpointMetadataFromConfig();\n            if (metadata) {\n              metadataEntity.updateEndpointMetadata(metadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.CONFIG];\n            }\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {\n              // No need to update\n              return [2 /*return*/, AuthorityMetadataSource.CACHE];\n            }\n            return [4 /*yield*/, this.getEndpointMetadataFromNetwork()];\n          case 1:\n            metadata = _b.sent();\n            if (!metadata) return [3 /*break*/, 4];\n            if (!((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.azureRegion)) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.regionDiscovery.detectRegion(this.authorityOptions.azureRegionConfiguration.environmentRegion, this.regionDiscoveryMetadata)];\n          case 2:\n            autodetectedRegionName = _b.sent();\n            azureRegion = this.authorityOptions.azureRegionConfiguration.azureRegion === Constants$1.AZURE_REGION_AUTO_DISCOVER_FLAG ? autodetectedRegionName : this.authorityOptions.azureRegionConfiguration.azureRegion;\n            if (this.authorityOptions.azureRegionConfiguration.azureRegion === Constants$1.AZURE_REGION_AUTO_DISCOVER_FLAG) {\n              this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ? RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL : RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\n            } else {\n              if (autodetectedRegionName) {\n                this.regionDiscoveryMetadata.region_outcome = this.authorityOptions.azureRegionConfiguration.azureRegion === autodetectedRegionName ? RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED : RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;\n              } else {\n                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\n              }\n            }\n            if (azureRegion) {\n              this.regionDiscoveryMetadata.region_used = azureRegion;\n              metadata = Authority.replaceWithRegionalInformation(metadata, azureRegion);\n            }\n            _b.label = 3;\n          case 3:\n            metadataEntity.updateEndpointMetadata(metadata, true);\n            return [2 /*return*/, AuthorityMetadataSource.NETWORK];\n          case 4:\n            throw ClientAuthError$1.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);\n        }\n      });\n    });\n  };\n  /**\r\n   * Compares the number of url components after the domain to determine if the cached authority metadata can be used for the requested authority\r\n   * Protects against same domain different authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\r\n   * @param metadataEntity\r\n   */\n  Authority.prototype.isAuthoritySameType = function (metadataEntity) {\n    var cachedAuthorityUrl = new UrlString$1(metadataEntity.canonical_authority);\n    var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\n  };\n  /**\r\n   * Parse authorityMetadata config option\r\n   */\n  Authority.prototype.getEndpointMetadataFromConfig = function () {\n    if (this.authorityOptions.authorityMetadata) {\n      try {\n        return JSON.parse(this.authorityOptions.authorityMetadata);\n      } catch (e) {\n        throw ClientConfigurationError$1.createInvalidAuthorityMetadataError();\n      }\n    }\n    return null;\n  };\n  /**\r\n   * Gets OAuth endpoints from the given OpenID configuration endpoint.\r\n   */\n  Authority.prototype.getEndpointMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var response, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint)];\n          case 1:\n            response = _a.sent();\n            return [2 /*return*/, isOpenIdConfigResponse(response.body) ? response.body : null];\n          case 2:\n            e_1 = _a.sent();\n            return [2 /*return*/, null];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache and returns where the information was retrived from\r\n   * @param cachedMetadata\r\n   * @param newMetadata\r\n   */\n  Authority.prototype.updateCloudDiscoveryMetadata = function (metadataEntity) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadata = this.getCloudDiscoveryMetadataFromConfig();\n            if (metadata) {\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.CONFIG];\n            }\n            // If The cached metadata came from config but that config was not passed to this instance, we must go to the network\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {\n              // No need to update\n              return [2 /*return*/, AuthorityMetadataSource.CACHE];\n            }\n            return [4 /*yield*/, this.getCloudDiscoveryMetadataFromNetwork()];\n          case 1:\n            metadata = _a.sent();\n            if (metadata) {\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n              return [2 /*return*/, AuthorityMetadataSource.NETWORK];\n            } else {\n              // Metadata could not be obtained from config, cache or network\n              throw ClientConfigurationError$1.createUntrustedAuthorityError();\n            }\n        }\n      });\n    });\n  };\n  /**\r\n   * Parse cloudDiscoveryMetadata config or check knownAuthorities\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromConfig = function () {\n    // Check if network response was provided in config\n    if (this.authorityOptions.cloudDiscoveryMetadata) {\n      try {\n        var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);\n        var metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);\n        if (metadata) {\n          return metadata;\n        }\n      } catch (e) {\n        throw ClientConfigurationError$1.createInvalidCloudDiscoveryMetadataError();\n      }\n    }\n    // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n    if (this.isInKnownAuthorities()) {\n      return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n    }\n    return null;\n  };\n  /**\r\n   * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\r\n   * @param networkInterface\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var instanceDiscoveryEndpoint, match, response, metadata, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            instanceDiscoveryEndpoint = \"\" + Constants$1.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + \"oauth2/v2.0/authorize\";\n            match = null;\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint)];\n          case 2:\n            response = _a.sent();\n            metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];\n            if (metadata.length === 0) {\n              // If no metadata is returned, authority is untrusted\n              return [2 /*return*/, null];\n            }\n            match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);\n            return [3 /*break*/, 4];\n          case 3:\n            e_2 = _a.sent();\n            return [2 /*return*/, null];\n          case 4:\n            if (!match) {\n              // Custom Domain scenario, host is trusted because Instance Discovery call succeeded \n              match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n            }\n            return [2 /*return*/, match];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper function to determine if this host is included in the knownAuthorities config option\r\n   */\n  Authority.prototype.isInKnownAuthorities = function () {\n    var _this = this;\n    var matches = this.authorityOptions.knownAuthorities.filter(function (authority) {\n      return UrlString$1.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;\n    });\n    return matches.length > 0;\n  };\n  /**\r\n   * Creates cloud discovery metadata object from a given host\r\n   * @param host\r\n   */\n  Authority.createCloudDiscoveryMetadataFromHost = function (host) {\n    return {\n      preferred_network: host,\n      preferred_cache: host,\n      aliases: [host]\n    };\n  };\n  /**\r\n   * Searches instance discovery network response for the entry that contains the host in the aliases list\r\n   * @param response\r\n   * @param authority\r\n   */\n  Authority.getCloudDiscoveryMetadataFromNetworkResponse = function (response, authority) {\n    for (var i = 0; i < response.length; i++) {\n      var metadata = response[i];\n      if (metadata.aliases.indexOf(authority) > -1) {\n        return metadata;\n      }\n    }\n    return null;\n  };\n  /**\r\n   * helper function to generate environment from authority object\r\n   */\n  Authority.prototype.getPreferredCache = function () {\n    if (this.discoveryComplete()) {\n      return this.metadata.preferred_cache;\n    } else {\n      throw ClientAuthError$1.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n    }\n  };\n  /**\r\n   * Returns whether or not the provided host is an alias of this authority instance\r\n   * @param host\r\n   */\n  Authority.prototype.isAlias = function (host) {\n    return this.metadata.aliases.indexOf(host) > -1;\n  };\n  /**\r\n   * Checks whether the provided host is that of a public cloud authority\r\n   *\r\n   * @param authority string\r\n   * @returns bool\r\n   */\n  Authority.isPublicCloudAuthority = function (host) {\n    return Constants$1.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n  };\n  /**\r\n   * Rebuild the authority string with the region\r\n   *\r\n   * @param host string\r\n   * @param region string\r\n   */\n  Authority.buildRegionalAuthorityString = function (host, region, queryString) {\n    // Create and validate a Url string object with the initial authority string\n    var authorityUrlInstance = new UrlString$1(host);\n    authorityUrlInstance.validateAsUri();\n    var authorityUrlParts = authorityUrlInstance.getUrlComponents();\n    var hostNameAndPort = region + \".\" + authorityUrlParts.HostNameAndPort;\n    if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n      hostNameAndPort = region + \".\" + Constants$1.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;\n    }\n    // Include the query string portion of the url\n    var url = UrlString$1.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), {\n      HostNameAndPort: hostNameAndPort\n    })).urlString;\n    // Add the query string if a query string was provided\n    if (queryString) return url + \"?\" + queryString;\n    return url;\n  };\n  /**\r\n   * Replace the endpoints in the metadata object with their regional equivalents.\r\n   *\r\n   * @param metadata OpenIdConfigResponse\r\n   * @param azureRegion string\r\n   */\n  Authority.replaceWithRegionalInformation = function (metadata, azureRegion) {\n    metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);\n    // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature\n    metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, \"allowestsrnonmsi=true\");\n    metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);\n    return metadata;\n  };\n  return Authority;\n}();\nexport { Authority };","map":{"version":3,"mappings":"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","names":["authority","networkInterface","cacheManager","authorityOptions","canonicalAuthority","_canonicalAuthority","validateAsUri","regionDiscovery","RegionDiscovery","regionDiscoveryMetadata","region_used","undefined","region_source","region_outcome","Object","Authority","pathSegments","canonicalAuthorityUrlComponents","PathSegments","length","toLowerCase","Constants","ADFS","AuthorityType","Adfs","Default","protocolMode","urlString","url","UrlString","_canonicalAuthorityUrlComponents","getUrlComponents","HostNameAndPort","discoveryComplete","endpoint","replacePath","metadata","authorization_endpoint","replaceTenant","ClientAuthError","createEndpointDiscoveryIncompleteError","token_endpoint","replace","end_session_endpoint","issuer","tenant","cachedAuthorityUrl","canonical_authority","cachedAuthorityParts","currentAuthorityParts","forEach","currentPart","index","cachedPart","authorityType","ProtocolMode","OIDC","metadataEntity","getAuthorityMetadataByAlias","hostnameAndPort","AuthorityMetadataEntity","updateCanonicalAuthority","updateCloudDiscoveryMetadata","cloudDiscoverySource","_a","preferred_network","updateEndpointMetadata","endpointSource","AuthorityMetadataSource","CACHE","resetExpiresAt","cacheKey","generateAuthorityMetadataCacheKey","preferred_cache","setAuthorityMetadata","getEndpointMetadataFromConfig","CONFIG","isAuthoritySameType","endpointsFromNetwork","isExpired","getEndpointMetadataFromNetwork","_b","azureRegionConfiguration","azureRegion","detectRegion","environmentRegion","autodetectedRegionName","AZURE_REGION_AUTO_DISCOVER_FLAG","RegionDiscoveryOutcomes","AUTO_DETECTION_REQUESTED_SUCCESSFUL","AUTO_DETECTION_REQUESTED_FAILED","CONFIGURED_MATCHES_DETECTED","CONFIGURED_NOT_DETECTED","CONFIGURED_NO_AUTO_DETECTION","replaceWithRegionalInformation","NETWORK","createUnableToGetOpenidConfigError","defaultOpenIdConfigurationEndpoint","cachedParts","authorityMetadata","JSON","parse","e","ClientConfigurationError","createInvalidAuthorityMetadataError","sendGetRequestAsync","response","isOpenIdConfigResponse","body","getCloudDiscoveryMetadataFromConfig","aliasesFromNetwork","getCloudDiscoveryMetadataFromNetwork","createUntrustedAuthorityError","cloudDiscoveryMetadata","parsedResponse","getCloudDiscoveryMetadataFromNetworkResponse","createInvalidCloudDiscoveryMetadataError","isInKnownAuthorities","createCloudDiscoveryMetadataFromHost","instanceDiscoveryEndpoint","AAD_INSTANCE_DISCOVERY_ENDPT","match","isCloudInstanceDiscoveryResponse","matches","knownAuthorities","filter","getDomainFromUrl","_this","host","aliases","i","indexOf","KNOWN_PUBLIC_CLOUDS","region","queryString","authorityUrlInstance","authorityUrlParts","hostNameAndPort","isPublicCloudAuthority","REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX","constructAuthorityUriFromObject","buildRegionalAuthorityString"],"sources":["../../src/authority/Authority.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AuthorityType } from \"./AuthorityType\";\r\nimport { isOpenIdConfigResponse, OpenIdConfigResponse } from \"./OpenIdConfigResponse\";\r\nimport { UrlString } from \"../url/UrlString\";\r\nimport { IUri } from \"../url/IUri\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { INetworkModule } from \"../network/INetworkModule\";\r\nimport { AuthorityMetadataSource, Constants, RegionDiscoveryOutcomes } from \"../utils/Constants\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ProtocolMode } from \"./ProtocolMode\";\r\nimport { ICacheManager } from \"../cache/interface/ICacheManager\";\r\nimport { AuthorityMetadataEntity } from \"../cache/entities/AuthorityMetadataEntity\";\r\nimport { AuthorityOptions } from \"./AuthorityOptions\";\r\nimport { CloudInstanceDiscoveryResponse, isCloudInstanceDiscoveryResponse } from \"./CloudInstanceDiscoveryResponse\";\r\nimport { CloudDiscoveryMetadata } from \"./CloudDiscoveryMetadata\";\r\nimport { RegionDiscovery } from \"./RegionDiscovery\";\r\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\r\n\r\n/**\r\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\r\n * endpoint. It will store the pertinent config data in this object for use during token calls.\r\n */\r\nexport class Authority {\r\n\r\n    // Canonical authority url string\r\n    private _canonicalAuthority: UrlString;\r\n    // Canonicaly authority url components\r\n    private _canonicalAuthorityUrlComponents: IUri | null;\r\n    // Network interface to make requests with.\r\n    protected networkInterface: INetworkModule;\r\n    // Cache Manager to cache network responses\r\n    protected cacheManager: ICacheManager;\r\n    // Protocol mode to construct endpoints\r\n    private authorityOptions: AuthorityOptions;\r\n    // Authority metadata\r\n    private metadata: AuthorityMetadataEntity;\r\n    // Region discovery service\r\n    private regionDiscovery: RegionDiscovery;\r\n    // Region discovery metadata\r\n    public regionDiscoveryMetadata: RegionDiscoveryMetadata;\r\n\r\n    constructor(authority: string, networkInterface: INetworkModule, cacheManager: ICacheManager, authorityOptions: AuthorityOptions) {\r\n        this.canonicalAuthority = authority;\r\n        this._canonicalAuthority.validateAsUri();\r\n        this.networkInterface = networkInterface;\r\n        this.cacheManager = cacheManager;\r\n        this.authorityOptions = authorityOptions;\r\n        this.regionDiscovery = new RegionDiscovery(networkInterface);\r\n        this.regionDiscoveryMetadata = { region_used: undefined, region_source: undefined, region_outcome: undefined };\r\n    }\r\n\r\n    // See above for AuthorityType\r\n    public get authorityType(): AuthorityType {\r\n        const pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\r\n\r\n        if (pathSegments.length && pathSegments[0].toLowerCase() === Constants.ADFS) {\r\n            return AuthorityType.Adfs;\r\n        }\r\n\r\n        return AuthorityType.Default;\r\n    }\r\n\r\n    /**\r\n     * ProtocolMode enum representing the way endpoints are constructed.\r\n     */\r\n    public get protocolMode(): ProtocolMode {\r\n        return this.authorityOptions.protocolMode;\r\n    }\r\n\r\n    /**\r\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\r\n     */\r\n    public get options(): AuthorityOptions {\r\n        return this.authorityOptions;\r\n    }\r\n\r\n    /**\r\n     * A URL that is the authority set by the developer\r\n     */\r\n    public get canonicalAuthority(): string {\r\n        return this._canonicalAuthority.urlString;\r\n    }\r\n\r\n    /**\r\n     * Sets canonical authority.\r\n     */\r\n    public set canonicalAuthority(url: string) {\r\n        this._canonicalAuthority = new UrlString(url);\r\n        this._canonicalAuthority.validateAsUri();\r\n        this._canonicalAuthorityUrlComponents = null;\r\n    }\r\n\r\n    /**\r\n     * Get authority components.\r\n     */\r\n    public get canonicalAuthorityUrlComponents(): IUri {\r\n        if (!this._canonicalAuthorityUrlComponents) {\r\n            this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\r\n        }\r\n\r\n        return this._canonicalAuthorityUrlComponents;\r\n    }\r\n\r\n    /**\r\n     * Get hostname and port i.e. login.microsoftonline.com\r\n     */\r\n    public get hostnameAndPort(): string {\r\n        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Get tenant for authority.\r\n     */\r\n    public get tenant(): string {\r\n        return this.canonicalAuthorityUrlComponents.PathSegments[0];\r\n    }\r\n\r\n    /**\r\n     * OAuth /authorize endpoint for requests\r\n     */\r\n    public get authorizationEndpoint(): string {\r\n        if(this.discoveryComplete()) {\r\n            const endpoint = this.replacePath(this.metadata.authorization_endpoint);\r\n            return this.replaceTenant(endpoint);\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * OAuth /token endpoint for requests\r\n     */\r\n    public get tokenEndpoint(): string {\r\n        if(this.discoveryComplete()) {\r\n            const endpoint = this.replacePath(this.metadata.token_endpoint);\r\n            return this.replaceTenant(endpoint);\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    public get deviceCodeEndpoint(): string {\r\n        if(this.discoveryComplete()) {\r\n            const endpoint = this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\r\n            return this.replaceTenant(endpoint);\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * OAuth logout endpoint for requests\r\n     */\r\n    public get endSessionEndpoint(): string {\r\n        if(this.discoveryComplete()) {\r\n            const endpoint = this.replacePath(this.metadata.end_session_endpoint);\r\n            return this.replaceTenant(endpoint);\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * OAuth issuer for requests\r\n     */\r\n    public get selfSignedJwtAudience(): string {\r\n        if(this.discoveryComplete()) {\r\n            const endpoint = this.replacePath(this.metadata.issuer);\r\n            return this.replaceTenant(endpoint);\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces tenant in url path with current tenant. Defaults to common.\r\n     * @param urlString\r\n     */\r\n    private replaceTenant(urlString: string): string {\r\n        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\r\n    }\r\n\r\n    /**\r\n     * Replaces path such as tenant or policy with the current tenant or policy.\r\n     * @param urlString \r\n     */\r\n    private replacePath(urlString: string): string {\r\n        let endpoint = urlString;\r\n        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\r\n        const cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\r\n        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\r\n\r\n        currentAuthorityParts.forEach((currentPart, index) => {\r\n            const cachedPart = cachedAuthorityParts[index];\r\n            if (currentPart !== cachedPart) {\r\n                endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);\r\n            }\r\n        });\r\n\r\n        return endpoint;\r\n    }\r\n\r\n    /**\r\n     * The default open id configuration endpoint for any canonical authority.\r\n     */\r\n    protected get defaultOpenIdConfigurationEndpoint(): string {\r\n        if (this.authorityType === AuthorityType.Adfs || this.protocolMode === ProtocolMode.OIDC) {\r\n            return `${this.canonicalAuthority}.well-known/openid-configuration`;\r\n        }\r\n        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;\r\n    }\r\n\r\n    /**\r\n     * Boolean that returns whethr or not tenant discovery has been completed.\r\n     */\r\n    discoveryComplete(): boolean {\r\n        return !!this.metadata;\r\n    }\r\n\r\n    /**\r\n     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\r\n     * and the /authorize, /token and logout endpoints.\r\n     */\r\n    public async resolveEndpointsAsync(): Promise<void> {\r\n        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\r\n        if (!metadataEntity) {\r\n            metadataEntity = new AuthorityMetadataEntity();\r\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\r\n        }\r\n\r\n        const cloudDiscoverySource = await this.updateCloudDiscoveryMetadata(metadataEntity);\r\n        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\r\n        const endpointSource = await this.updateEndpointMetadata(metadataEntity);\r\n\r\n        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {\r\n            // Reset the expiration time unless both values came from a successful cache lookup\r\n            metadataEntity.resetExpiresAt();\r\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\r\n        } \r\n\r\n        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\r\n        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\r\n        this.metadata = metadataEntity;\r\n    }\r\n\r\n    /**\r\n     * Update AuthorityMetadataEntity with new endpoints and return where the information came from\r\n     * @param metadataEntity \r\n     */\r\n    private async updateEndpointMetadata(metadataEntity: AuthorityMetadataEntity): Promise<AuthorityMetadataSource> {\r\n        let metadata = this.getEndpointMetadataFromConfig();\r\n        if (metadata) {\r\n            metadataEntity.updateEndpointMetadata(metadata, false);\r\n            return AuthorityMetadataSource.CONFIG;\r\n        }\r\n\r\n        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {\r\n            // No need to update\r\n            return AuthorityMetadataSource.CACHE;\r\n        }\r\n\r\n        metadata = await this.getEndpointMetadataFromNetwork();\r\n        if (metadata) {\r\n            // If the user prefers to use an azure region replace the global endpoints with regional information.\r\n            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\r\n                const autodetectedRegionName = await this.regionDiscovery.detectRegion(this.authorityOptions.azureRegionConfiguration.environmentRegion, this.regionDiscoveryMetadata);\r\n\r\n                const azureRegion = this.authorityOptions.azureRegionConfiguration.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG \r\n                    ? autodetectedRegionName \r\n                    : this.authorityOptions.azureRegionConfiguration.azureRegion;\r\n\r\n                if (this.authorityOptions.azureRegionConfiguration.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {\r\n                    this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ?\r\n                        RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL :\r\n                        RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\r\n                } else {\r\n                    if (autodetectedRegionName) {\r\n                        this.regionDiscoveryMetadata.region_outcome = (this.authorityOptions.azureRegionConfiguration.azureRegion === autodetectedRegionName) ?\r\n                            RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED :\r\n                            RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;\r\n                    } else {\r\n                        this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\r\n                    }\r\n                }\r\n\r\n                if (azureRegion) {\r\n                    this.regionDiscoveryMetadata.region_used = azureRegion;\r\n                    metadata = Authority.replaceWithRegionalInformation(metadata, azureRegion);\r\n                }\r\n            }\r\n\r\n            metadataEntity.updateEndpointMetadata(metadata, true);\r\n            return AuthorityMetadataSource.NETWORK;\r\n        } else {\r\n            throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compares the number of url components after the domain to determine if the cached authority metadata can be used for the requested authority\r\n     * Protects against same domain different authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\r\n     * @param metadataEntity\r\n     */\r\n    private isAuthoritySameType(metadataEntity: AuthorityMetadataEntity): boolean {\r\n        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\r\n        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\r\n        \r\n        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\r\n    }\r\n\r\n    /**\r\n     * Parse authorityMetadata config option\r\n     */\r\n    private getEndpointMetadataFromConfig(): OpenIdConfigResponse | null {\r\n        if (this.authorityOptions.authorityMetadata) {\r\n            try {\r\n                return JSON.parse(this.authorityOptions.authorityMetadata) as OpenIdConfigResponse;\r\n            } catch (e) {\r\n                throw ClientConfigurationError.createInvalidAuthorityMetadataError();\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets OAuth endpoints from the given OpenID configuration endpoint.\r\n     */\r\n    private async getEndpointMetadataFromNetwork(): Promise<OpenIdConfigResponse | null> {\r\n        try {\r\n            const response = await this.networkInterface.sendGetRequestAsync<OpenIdConfigResponse>(this.defaultOpenIdConfigurationEndpoint);\r\n            return isOpenIdConfigResponse(response.body) ? response.body : null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache and returns where the information was retrived from\r\n     * @param cachedMetadata \r\n     * @param newMetadata \r\n     */\r\n    private async updateCloudDiscoveryMetadata(metadataEntity: AuthorityMetadataEntity): Promise<AuthorityMetadataSource> {\r\n        let metadata = this.getCloudDiscoveryMetadataFromConfig();\r\n        if (metadata) {\r\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\r\n            return AuthorityMetadataSource.CONFIG;\r\n        }\r\n\r\n        // If The cached metadata came from config but that config was not passed to this instance, we must go to the network\r\n        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {\r\n            // No need to update\r\n            return AuthorityMetadataSource.CACHE;\r\n        }\r\n\r\n        metadata = await this.getCloudDiscoveryMetadataFromNetwork();\r\n        if (metadata) {\r\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\r\n            return AuthorityMetadataSource.NETWORK;\r\n        } else {\r\n            // Metadata could not be obtained from config, cache or network\r\n            throw ClientConfigurationError.createUntrustedAuthorityError();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse cloudDiscoveryMetadata config or check knownAuthorities\r\n     */\r\n    private getCloudDiscoveryMetadataFromConfig(): CloudDiscoveryMetadata | null {\r\n        // Check if network response was provided in config\r\n        if (this.authorityOptions.cloudDiscoveryMetadata) {\r\n            try {\r\n                const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata) as CloudInstanceDiscoveryResponse;\r\n                const metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);\r\n                if (metadata) {\r\n                    return metadata;\r\n                }\r\n            } catch (e) {\r\n                throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();\r\n            }\r\n        }\r\n\r\n        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\r\n        if (this.isInKnownAuthorities()) {\r\n            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\r\n     * @param networkInterface \r\n     */\r\n    private async getCloudDiscoveryMetadataFromNetwork(): Promise<CloudDiscoveryMetadata | null> {\r\n        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;\r\n        let match = null;\r\n        try {\r\n            const response = await this.networkInterface.sendGetRequestAsync<CloudInstanceDiscoveryResponse>(instanceDiscoveryEndpoint);\r\n            const metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];\r\n            if (metadata.length === 0) {\r\n                // If no metadata is returned, authority is untrusted\r\n                return null;\r\n            }\r\n            match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);\r\n        } catch(e) {\r\n            return null;\r\n        }\r\n\r\n        if (!match) {\r\n            // Custom Domain scenario, host is trusted because Instance Discovery call succeeded \r\n            match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\r\n        }\r\n        return match;\r\n    } \r\n\r\n    /**\r\n     * Helper function to determine if this host is included in the knownAuthorities config option\r\n     */\r\n    private isInKnownAuthorities(): boolean {\r\n        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {\r\n            return UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;\r\n        });\r\n\r\n        return matches.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Creates cloud discovery metadata object from a given host\r\n     * @param host \r\n     */\r\n    static createCloudDiscoveryMetadataFromHost(host: string): CloudDiscoveryMetadata {\r\n        return {\r\n            preferred_network: host,\r\n            preferred_cache: host,\r\n            aliases: [host]\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Searches instance discovery network response for the entry that contains the host in the aliases list\r\n     * @param response \r\n     * @param authority \r\n     */\r\n    static getCloudDiscoveryMetadataFromNetworkResponse(response: CloudDiscoveryMetadata[], authority: string): CloudDiscoveryMetadata | null {\r\n        for (let i = 0; i < response.length; i++) {\r\n            const metadata = response[i];\r\n            if (metadata.aliases.indexOf(authority) > -1) {\r\n                return metadata;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * helper function to generate environment from authority object\r\n     */\r\n    getPreferredCache(): string {\r\n        if(this.discoveryComplete()) {\r\n            return this.metadata.preferred_cache;\r\n        } else {\r\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the provided host is an alias of this authority instance\r\n     * @param host \r\n     */\r\n    isAlias(host: string): boolean {\r\n        return this.metadata.aliases.indexOf(host) > -1;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the provided host is that of a public cloud authority\r\n     * \r\n     * @param authority string\r\n     * @returns bool\r\n     */\r\n    static isPublicCloudAuthority(host: string): boolean {\r\n        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the authority string with the region\r\n     * \r\n     * @param host string\r\n     * @param region string \r\n     */\r\n    static buildRegionalAuthorityString(host: string, region: string, queryString?: string): string {\r\n        // Create and validate a Url string object with the initial authority string\r\n        const authorityUrlInstance = new UrlString(host);\r\n        authorityUrlInstance.validateAsUri();\r\n\r\n        const authorityUrlParts = authorityUrlInstance.getUrlComponents();\r\n\r\n        let hostNameAndPort= `${region}.${authorityUrlParts.HostNameAndPort}`;\r\n\r\n        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\r\n            hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;\r\n        }\r\n\r\n        // Include the query string portion of the url\r\n        const url = UrlString.constructAuthorityUriFromObject({\r\n            ...authorityUrlInstance.getUrlComponents(),\r\n            HostNameAndPort: hostNameAndPort\r\n        }).urlString;\r\n\r\n        // Add the query string if a query string was provided\r\n        if (queryString) return `${url}?${queryString}`;\r\n\r\n        return url;\r\n    }\r\n\r\n    /**\r\n     * Replace the endpoints in the metadata object with their regional equivalents.\r\n     * \r\n     * @param metadata OpenIdConfigResponse\r\n     * @param azureRegion string\r\n     */\r\n    static replaceWithRegionalInformation(metadata: OpenIdConfigResponse, azureRegion: string): OpenIdConfigResponse {\r\n        metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);\r\n        // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature\r\n        metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, \"allowestsrnonmsi=true\");\r\n        metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);\r\n        \r\n        return metadata;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}