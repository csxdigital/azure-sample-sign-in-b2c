{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { RegionDiscoverySources, ResponseCodes, Constants as Constants$1 } from '../utils/Constants.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar RegionDiscovery = /** @class */function () {\n  function RegionDiscovery(networkInterface) {\n    this.networkInterface = networkInterface;\n  }\n  /**\r\n   * Detect the region from the application's environment.\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  RegionDiscovery.prototype.detectRegion = function (environmentRegion, regionDiscoveryMetadata) {\n    return __awaiter(this, void 0, void 0, function () {\n      var autodetectedRegionName, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            autodetectedRegionName = environmentRegion;\n            if (!!autodetectedRegionName) return [3 /*break*/, 8];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 6,, 7]);\n            return [4 /*yield*/, this.getRegionFromIMDS(Constants$1.IMDS_VERSION)];\n          case 2:\n            localIMDSVersionResponse = _a.sent();\n            if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = localIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n            if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest)) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.getCurrentVersion()];\n          case 3:\n            currentIMDSVersion = _a.sent();\n            if (!currentIMDSVersion) {\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n              return [2 /*return*/, null];\n            }\n            return [4 /*yield*/, this.getRegionFromIMDS(currentIMDSVersion)];\n          case 4:\n            currentIMDSVersionResponse = _a.sent();\n            if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = currentIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n            _a.label = 5;\n          case 5:\n            return [3 /*break*/, 7];\n          case 6:\n            e_1 = _a.sent();\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            return [2 /*return*/, null];\n          case 7:\n            return [3 /*break*/, 9];\n          case 8:\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n            _a.label = 9;\n          case 9:\n            // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n            if (!autodetectedRegionName) {\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            }\n            return [2 /*return*/, autodetectedRegionName || null];\n        }\n      });\n    });\n  };\n  /**\r\n   * Make the call to the IMDS endpoint\r\n   *\r\n   * @param imdsEndpointUrl\r\n   * @returns Promise<NetworkResponse<string>>\r\n   */\n  RegionDiscovery.prototype.getRegionFromIMDS = function (version) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.networkInterface.sendGetRequestAsync(Constants$1.IMDS_ENDPOINT + \"?api-version=\" + version + \"&format=text\", RegionDiscovery.IMDS_OPTIONS, Constants$1.IMDS_TIMEOUT)];\n      });\n    });\n  };\n  /**\r\n   * Get the most recent version of the IMDS endpoint available\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  RegionDiscovery.prototype.getCurrentVersion = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var response, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(Constants$1.IMDS_ENDPOINT + \"?format=json\", RegionDiscovery.IMDS_OPTIONS)];\n          case 1:\n            response = _a.sent();\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n            if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n              return [2 /*return*/, response.body[\"newest-versions\"][0]];\n            }\n            return [2 /*return*/, null];\n          case 2:\n            e_2 = _a.sent();\n            return [2 /*return*/, null];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  // Options for the IMDS endpoint request\n  RegionDiscovery.IMDS_OPTIONS = {\n    headers: {\n      \"Metadata\": \"true\"\n    }\n  };\n  return RegionDiscovery;\n}();\nexport { RegionDiscovery };","map":{"version":3,"mappings":";;;;;;AAAA;;;;;EAiBI,yBAAYA,gBAAgC;IACxC,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;;;;;;;EAQ/BC,sCAAY,GAAzB,UAA0BC,iBAAqC,EAAEC,uBAAgD;;;;;;YAEzGC,sBAAsB,GAAGF,iBAAiB;iBAG1C,CAACE,sBAAsB,EAAvB;;;;YAEqC,qBAAM,IAAI,CAACC,iBAAiB,CAACC,WAAS,CAACC,YAAY,CAAC;;YAA/EC,wBAAwB,GAAGC,SAAoD;YACrF,IAAID,wBAAwB,CAACE,MAAM,KAAKC,aAAa,CAACC,WAAW,EAAE;cAC/DR,sBAAsB,GAAGI,wBAAwB,CAACK,IAAI;cACtDV,uBAAuB,CAACW,aAAa,GAAGC,sBAAsB,CAACC,IAAI;;kBAInER,wBAAwB,CAACE,MAAM,KAAKC,aAAa,CAACM,cAAc,GAAhE;YAC2B,qBAAM,IAAI,CAACC,iBAAiB,EAAE;;YAAnDC,kBAAkB,GAAGV,SAA8B;YACzD,IAAI,CAACU,kBAAkB,EAAE;cACrBhB,uBAAuB,CAACW,aAAa,GAAGC,sBAAsB,CAACK,qBAAqB;cACpF,sBAAO,IAAI;;YAGoB,qBAAM,IAAI,CAACf,iBAAiB,CAACc,kBAAkB,CAAC;;YAA7EE,0BAA0B,GAAGZ,SAAgD;YACnF,IAAIY,0BAA0B,CAACX,MAAM,KAAKC,aAAa,CAACC,WAAW,EAAE;cACjER,sBAAsB,GAAGiB,0BAA0B,CAACR,IAAI;cACxDV,uBAAuB,CAACW,aAAa,GAAGC,sBAAsB,CAACC,IAAI;;;;;;;YAI3Eb,uBAAuB,CAACW,aAAa,GAAGC,sBAAsB,CAACK,qBAAqB;YACpF,sBAAO,IAAI;;;;YAGfjB,uBAAuB,CAACW,aAAa,GAAGC,sBAAsB,CAACO,oBAAoB;;;;YAIvF,IAAI,CAAClB,sBAAsB,EAAE;cACzBD,uBAAuB,CAACW,aAAa,GAAGC,sBAAsB,CAACK,qBAAqB;;YAGxF,sBAAOhB,sBAAsB,IAAI,IAAI;QAAC;;;GACzC;;;;;;;EAQaH,2CAAiB,GAA/B,UAAgCsB,OAAe;;;QAC3C,sBAAO,IAAI,CAACvB,gBAAgB,CAACwB,mBAAmB,CAAYlB,WAAS,CAACmB,aAAa,qBAAgBF,OAAO,iBAAc,EAAEtB,eAAe,CAACyB,YAAY,EAAEpB,WAAS,CAACqB,YAAY,CAAC;;;GAClL;;;;;;EAOa1B,2CAAiB,GAA/B;;;;;;;YAEyB,qBAAM,IAAI,CAACD,gBAAgB,CAACwB,mBAAmB,CAAqBlB,WAAS,CAACmB,aAAa,iBAAc,EAAExB,eAAe,CAACyB,YAAY,CAAC;;YAAnJE,QAAQ,GAAGnB,SAAwI;;YAGzJ,IAAImB,QAAQ,CAAClB,MAAM,KAAKC,aAAa,CAACM,cAAc,IAAIW,QAAQ,CAACf,IAAI,IAAIe,QAAQ,CAACf,IAAI,CAAC,iBAAiB,CAAC,IAAIe,QAAQ,CAACf,IAAI,CAAC,iBAAiB,CAAC,CAACgB,MAAM,GAAG,CAAC,EAAE;cACtJ,sBAAOD,QAAQ,CAACf,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;;YAG9C,sBAAO,IAAI;;;YAEX,sBAAO,IAAI;;;;;;GAElB;;EAlFgBZ,4BAAY,GAAG;IAAC6B,OAAO,EAAE;MAAC,UAAU,EAAE;IAAM;EAAC,CAAC;EAmFnE,sBAAC;CAvFD","names":["networkInterface","RegionDiscovery","environmentRegion","regionDiscoveryMetadata","autodetectedRegionName","getRegionFromIMDS","Constants","IMDS_VERSION","localIMDSVersionResponse","_a","status","ResponseCodes","httpSuccess","body","region_source","RegionDiscoverySources","IMDS","httpBadRequest","getCurrentVersion","currentIMDSVersion","FAILED_AUTO_DETECTION","currentIMDSVersionResponse","ENVIRONMENT_VARIABLE","version","sendGetRequestAsync","IMDS_ENDPOINT","IMDS_OPTIONS","IMDS_TIMEOUT","response","length","headers"],"sources":["../../src/authority/RegionDiscovery.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { INetworkModule } from \"../network/INetworkModule\";\r\nimport { NetworkResponse } from \"../network/NetworkManager\";\r\nimport { IMDSBadResponse } from \"../response/IMDSBadResponse\";\r\nimport { Constants, RegionDiscoverySources, ResponseCodes } from \"../utils/Constants\";\r\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\r\n\r\nexport class RegionDiscovery {\r\n    // Network interface to make requests with.\r\n    protected networkInterface: INetworkModule;\r\n    // Options for the IMDS endpoint request\r\n    protected static IMDS_OPTIONS = {headers: {\"Metadata\": \"true\"}};\r\n\r\n    constructor(networkInterface: INetworkModule) {\r\n        this.networkInterface = networkInterface;\r\n    }\r\n\r\n    /**\r\n     * Detect the region from the application's environment.\r\n     * \r\n     * @returns Promise<string | null>\r\n     */\r\n    public async detectRegion(environmentRegion: string | undefined, regionDiscoveryMetadata: RegionDiscoveryMetadata): Promise<string | null> {\r\n        // Initialize auto detected region with the region from the envrionment \r\n        let autodetectedRegionName = environmentRegion;\r\n\r\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS \r\n        if (!autodetectedRegionName) {\r\n            try {\r\n                const localIMDSVersionResponse = await this.getRegionFromIMDS(Constants.IMDS_VERSION);\r\n                if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\r\n                    autodetectedRegionName = localIMDSVersionResponse.body;\r\n                    regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\r\n                } \r\n                \r\n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry. \r\n                if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {\r\n                    const currentIMDSVersion = await this.getCurrentVersion();\r\n                    if (!currentIMDSVersion) {\r\n                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n                        return null;\r\n                    }\r\n\r\n                    const currentIMDSVersionResponse = await this.getRegionFromIMDS(currentIMDSVersion);\r\n                    if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\r\n                        autodetectedRegionName = currentIMDSVersionResponse.body;\r\n                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\r\n                    }\r\n                }\r\n            } catch(e) {\r\n                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n                return null;\r\n            } \r\n        } else {\r\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\r\n        }\r\n\r\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\r\n        if (!autodetectedRegionName) {\r\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n        }\r\n\r\n        return autodetectedRegionName || null;\r\n    }\r\n\r\n    /**\r\n     * Make the call to the IMDS endpoint\r\n     * \r\n     * @param imdsEndpointUrl\r\n     * @returns Promise<NetworkResponse<string>>\r\n     */\r\n    private async getRegionFromIMDS(version: string): Promise<NetworkResponse<string>> {\r\n        return this.networkInterface.sendGetRequestAsync<string>(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, RegionDiscovery.IMDS_OPTIONS, Constants.IMDS_TIMEOUT);\r\n    }\r\n\r\n    /**\r\n     * Get the most recent version of the IMDS endpoint available\r\n     *  \r\n     * @returns Promise<string | null>\r\n     */\r\n    private async getCurrentVersion(): Promise<string | null> {\r\n        try {\r\n            const response = await this.networkInterface.sendGetRequestAsync<IMDSBadResponse>(`${Constants.IMDS_ENDPOINT}?format=json`, RegionDiscovery.IMDS_OPTIONS);\r\n\r\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\r\n            if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\r\n                return response.body[\"newest-versions\"][0];\r\n            }\r\n\r\n            return null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}